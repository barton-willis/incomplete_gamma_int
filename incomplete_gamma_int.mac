/*
  Barton Willis
  Maxima code for integration of some functions whose antiderivative involves 
  either the incomplete gamma function or the Gauss hypergeometric function.

 License: CC0 1.0 Universal (https://creativecommons.org/publicdomain/zero/1.0/) */

load(ratpow);
load(quotify);
/* The function 'solve' evaluates its arguments. This code uses a workaround of this undocumented
   (miss) feature of 'solve' by quoting variables. The function 'quotify' substitutes a quoted mapatom for
   an unquoted mapatom. If this 'solve' feature is removed, the calls to `quotify` in this code
   should be removed.  Possibly another workaround is to use `algsys' not `solve.' Another workaround
   is to give the gensym variables defined in complete_gamma_int (and friends) weird names like '?a' 
   instead of 'a' */
load(quotify);

my_int(e,x) := block([antid : false, methods],
  methods : ['power_int, 'incomplete_gamma_int, 'hypergeometric_int],
  for fn in methods while antid = false do (
    antid : fn(e,x)),
  antid);
  
/* Return solve(e,x) in an environment with progammode : true, and ... globalsolve : false. */
solve_special_environment(e,x) := block([programmode : true, backsubst : true, realonly : false,
 breakup : true, solveexplicit : true, solvenullwarn : false, solvefactors : true, solveradcan : true,
 solvetrigwarn : false, solvedecomposes : true, globalsolve : false],
   solve(e,x))$

/* When 'e' is a mapatom, return false; otherwise return op(e) with inflag set to true.*/
safe_op(e) := block([inflag : true], if mapatom(e) then false else op(e));

/*Return the logarithmic derivative of the expression 'e' with respect to the variable 'x'.
  Of course, 'x' should be a nonconstant mapatom, but this function doesn't check that for
  that. */
logdiff(e,x) := diff(e,x)/e;

/* For a rational function 'r' in the variable 'x', return the degree of the 
denominator minus the degree of the numerator. This function does not check that
the input 'r' is rational in 'x'. */
pole_order(r,x) := hipow(ratexpand(ratdenom(r)),x) - hipow(ratexpand(ratnumer(r)),x);

/* Return a Maxima list of the first `m` digits of the base 'base' representation 
of the integer `n`. This function does not check that both `n` & `m` are positive 
integers. */
digits(n,m,base) := block([d : []],
        for k : 1 thru m do (
            n : divide(n,base),
            push(second(n),d),
            n : first(n)),
       d);

/* This function attempts to find a change of variable to convert the integrand
'e' to the form integrate(x^a * exp(-x), x) = -gamma_incomplete(1+a,x). This
method will be successful when the derivative change of variables is a product
of powers of the factors of the logarithmic derivative of the integrand 'e'. */
incomplete_gamma_int(e,x) := block([sigma, mu, kerns, n, N, resfn, a : gensym(),
   de, eqs, sol, α, f, k : 1, antid : false, errormsg : false],
   sigma : partfrac(gfactor(ratsimp(logdiff(e,x))),x),
   kerns : if safe_op(sigma) = "+" then args(sigma) else [sigma],
   kerns : sublist(kerns, lambda([s], pole_order(s,x) = 1)),
   resfn : lambda([z,k], if k = 0 then 0 else (z - logdiff(1/ratdenom(z),x))/(a+1)),
   n : length(kerns),
   N : 2^n,

   while  k <= N and (antid = false) do (
      mu : xreduce("+", map(resfn, kerns, digits(k,n,2))),
      k : k + 1,
      de : mu^2 *(diff(sigma,x) - mu*sigma + (a + 1) * mu^2) + mu*(mu-sigma)*diff(mu,x) - 
           mu*diff(mu,x,2) + 2*diff(mu,x)^2,      
      eqs : ratp_dense_coeffs(de,x),
      eqs : gfactor(eqs), 
      eqs : quotify(eqs,'a),
      sol : solve_special_environment(eqs,[a]),
      if sol # [] and sol # 'all then (     
        sol : first(sol),
        f : -(sigma/mu)+diff(mu,x,1)/mu^2+a+1,
        f : errcatch(ratsimp(subst(sol, f))),
        if f # [] then (
          f : first(f),
          α : subst(sol, ratsimp(e / (diff(f,x) * f^a * exp(-f)))), 
          α : block([rootsconmode : 'all], rootscontract(α)),
          /* This should be improved to allow things like abs(x)/x to pass. */
          if not freeof(α,x) then (
              print("unable to show that ",α," is piecewise constant")),
          antid : factor(-α * gamma_incomplete(subst(sol,a+1),f))))),
   antid);

/* seed for integrate(α x^a * (1-x)^b,x) */
hypergeometric_int(e,x) := block([sigma, mu, kerns, n, N, resfn, a : gensym(), b : gensym(),
   de, eqs, sol, solx, α, f, k : 1, αα, aa, bb, ff, antid : false, errormsg : false],

   sigma : partfrac(gfactor(logdiff(e,x)),x),
   kerns : if safe_op(sigma) = "+" then args(sigma) else [sigma],
   kerns : sublist(kerns, lambda([s], pole_order(s,x) = 1)),
   resfn : lambda([z,k], z : ratsimp(z - logdiff(z,x)), if k = 0 then 0 elseif k = 1 then z/(a+1) else z/(1+a+b)),

   n : length(kerns),
   N : 3^n,
   while  k <= N and (antid = false) do (
      mu : xreduce("+", map(resfn, kerns, digits(k,n,3))),
      k : k + 1,
      
      de : b*(mu^2*(diff(sigma,x,1))-mu*(diff(mu,x,1))*sigma-mu*(diff(mu,x,2))+
           2*(diff(mu,x,1))^2)+(mu*sigma-diff(mu,x,1)-a*mu^2-mu^2)*
           (mu*sigma-diff(mu,x,1)-b*mu^2-a*mu^2-mu^2),

      /* collect the numerators of a pfd of de*/
      de : partfrac(gfactor(de),x),
      eqs : if safe_op(de) = "+" then args(de) else [de],
      eqs : map(ratnumer, eqs),
      eqs : map(lambda([s], ratp_dense_coeffs(s,x)),eqs),
      eqs : xreduce('append, eqs), 
      eqs : quotify(eqs,'a, 'b),
      sol : solve_special_environment(eqs,[a,b]),
      if sol # [] and sol # 'all then (   

        f : [],
        while sol # [ ] and f = [] do (
          solx : pop(sol),
          f : (mu*sigma-diff(mu,x,1)+(-a-1)*mu^2)/(mu*sigma-diff(mu,x,1)+(-b-a-1)*mu^2),       
          f : errcatch(ratsimp(subst(solx, f)))),
      
        sol : solx,

        if f # [] then (
          f : first(f),
          α : subst(sol, ratsimp(e / (diff(f,x) * f^a * (1-f)^b))), 
          α : block([rootsconmode : 'all], rootscontract(α)),
          /* This should be improved to allow things like abs(x)/x to pass. */
          if not freeof(α,x) then (
              print("unable to show that ",α," is piecewise constant")),

          [αα,aa,bb,ff] : subst(sol, [α,a,b,f]),
          /* Maybe optionally apply hypergeometric_simp?*/  
          if not (integerp(aa) and 1 + aa <= 0) then (
             antid : factor(αα * f^(1+aa) * hypergeometric([1+aa, -bb], [2+aa], f)/(1+aa)))))),
   antid);

/* seed for integrate(α x^a,x) */
power_int(e,x) := block([sigma, mu, kerns, n, N, resfn, de, eqs, f, k : 1, antid : false, errormsg : false],

   sigma : partfrac(gfactor(logdiff(e,x)),x),
   kerns : if safe_op(sigma) = "+" then args(sigma) else [sigma],
   kerns : sublist(kerns, lambda([s], pole_order(s,x) = 1)),
   resfn : lambda([z,k], if k = 0 then 0 else z - logdiff(z,x)),
   n : length(kerns),
   N : 2^n,
   while  k <= N and (antid = false) do (
      mu : xreduce("+", map(resfn, kerns, digits(k,n,2))),
      k : k + 1,      
      de : -(mu*sigma)+diff(mu,x,1)+mu^2,
      de : gfactor(de),
      if equal(de,0) then (   
        f : factor(exp(integrate(mu,x))),  
        if mu # 0 then (
           α : ratsimp(e / diff(f,x)), 
           α : block([rootsconmode : 'all], rootscontract(α)),
           /* This should be improved to allow things like abs(x)/x to pass. */
           if not freeof(α,x) then (
              print("unable to show that ",α," is piecewise constant")),
           antid : factor(α * f)))),
         
   antid);
